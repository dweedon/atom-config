'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _types;

function _load_types() {
  return _types = require('./types');
}

var _child_process;

function _load_child_process() {
  return _child_process = require('child_process');
}

var _fs;

function _load_fs() {
  return _fs = require('fs');
}

var _os;

function _load_os() {
  return _os = require('os');
}

var _events;

function _load_events() {
  return _events = _interopRequireDefault(require('events'));
}

var _project_workspace;

function _load_project_workspace() {
  return _project_workspace = _interopRequireDefault(require('./project_workspace'));
}

var _Process;

function _load_Process() {
  return _Process = require('./Process');
}

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } } /**
                                                                                                                                                                                                 * Copyright (c) 2014-present, Facebook, Inc. All rights reserved.
                                                                                                                                                                                                 *
                                                                                                                                                                                                 * This source code is licensed under the MIT license found in the
                                                                                                                                                                                                 * LICENSE file in the root directory of this source tree.
                                                                                                                                                                                                 *
                                                                                                                                                                                                 * 
                                                                                                                                                                                                 */

// This class represents the running process, and
// passes out events when it understands what data is being
// pass sent out of the process
class Runner extends (_events || _load_events()).default {

  constructor(workspace, options) {
    super();

    this._createProcess = options && options.createProcess || (_Process || _load_Process()).createProcess;
    this.options = options || {};
    this.workspace = workspace;
    this.outputPath = (0, (_os || _load_os()).tmpdir)() + '/jest_runner.json';
    this.prevMessageTypes = [];
  }

  start() {
    let watchMode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
    let watchAll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    if (this.debugprocess) {
      return;
    }

    this.watchMode = watchMode;
    this.watchAll = watchAll;

    // Handle the arg change on v18
    const belowEighteen = this.workspace.localJestMajorVersion < 18;
    const outputArg = belowEighteen ? '--jsonOutputFile' : '--outputFile';

    const args = ['--json', '--useStderr', outputArg, this.outputPath];
    if (this.watchMode) {
      args.push(this.watchAll ? '--watchAll' : '--watch');
    }
    if (this.options.testNamePattern) {
      args.push('--testNamePattern', this.options.testNamePattern);
    }
    if (this.options.testFileNamePattern) {
      args.push(this.options.testFileNamePattern);
    }

    const options = {
      shell: this.options.shell
    };

    this.debugprocess = this._createProcess(this.workspace, args, options);
    this.debugprocess.stdout.on('data', data => {
      // Make jest save to a file, otherwise we get chunked data
      // and it can be hard to put it back together.
      const stringValue = data.toString().replace(/\n$/, '').trim();

      if (stringValue.startsWith('Test results written to')) {
        (0, (_fs || _load_fs()).readFile)(this.outputPath, 'utf8', (err, data) => {
          if (err) {
            const message = `JSON report not found at ${this.outputPath}`;
            this.emit('terminalError', message);
          } else {
            const noTestsFound = this.doResultsFollowNoTestsFoundMessage();
            this.emit('executableJSON', JSON.parse(data), { noTestsFound });
          }
        });
      } else {
        this.emit('executableOutput', stringValue.replace('[2J[H', ''));
      }
      this.prevMessageTypes.length = 0;
    });

    this.debugprocess.stderr.on('data', data => {
      const type = this.findMessageType(data);
      if (type === (_types || _load_types()).messageTypes.unknown) {
        this.prevMessageTypes.length = 0;
      } else {
        this.prevMessageTypes.push(type);
      }

      this.emit('executableStdErr', data, { type });
    });

    this.debugprocess.on('exit', () => {
      this.emit('debuggerProcessExit');
      this.prevMessageTypes.length = 0;
    });

    this.debugprocess.on('error', error => {
      this.emit('terminalError', 'Process failed: ' + error.message);
      this.prevMessageTypes.length = 0;
    });

    this.debugprocess.on('close', () => {
      this.emit('debuggerProcessExit');
      this.prevMessageTypes.length = 0;
    });
  }

  runJestWithUpdateForSnapshots(completion, args) {
    const defaultArgs = ['--updateSnapshot'];

    const options = { shell: this.options.shell };
    const updateProcess = this._createProcess(this.workspace, [].concat(defaultArgs, _toConsumableArray(args ? args : [])), options);
    updateProcess.on('close', () => {
      completion();
    });
  }

  closeProcess() {
    if (!this.debugprocess) {
      return;
    }
    if (process.platform === 'win32') {
      // Windows doesn't exit the process when it should.
      (0, (_child_process || _load_child_process()).spawn)('taskkill', ['/pid', '' + this.debugprocess.pid, '/T', '/F']);
    } else {
      this.debugprocess.kill();
    }
    delete this.debugprocess;
  }

  findMessageType(buf) {
    const str = buf.toString('utf8', 0, 58);
    if (str === 'No tests found related to files changed since last commit.') {
      return (_types || _load_types()).messageTypes.noTests;
    }

    if (/^\s*Watch Usage\b/.test(str)) {
      return (_types || _load_types()).messageTypes.watchUsage;
    }

    return (_types || _load_types()).messageTypes.unknown;
  }

  doResultsFollowNoTestsFoundMessage() {
    if (this.prevMessageTypes.length === 1) {
      return this.prevMessageTypes[0] === (_types || _load_types()).messageTypes.noTests;
    }

    if (this.prevMessageTypes.length === 2) {
      return this.prevMessageTypes[0] === (_types || _load_types()).messageTypes.noTests && this.prevMessageTypes[1] === (_types || _load_types()).messageTypes.watchUsage;
    }

    return false;
  }
}
exports.default = Runner;