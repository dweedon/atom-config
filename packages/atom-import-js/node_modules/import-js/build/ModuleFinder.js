Object.defineProperty(exports, "__esModule", {
  value: true
});

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _requireRelative = require('require-relative');

var _requireRelative2 = _interopRequireDefault(_requireRelative);

var _winston = require('winston');

var _winston2 = _interopRequireDefault(_winston);

var _ExportsStorage = require('./ExportsStorage');

var _ExportsStorage2 = _interopRequireDefault(_ExportsStorage);

var _Watcher = require('./Watcher');

var _Watcher2 = _interopRequireDefault(_Watcher);

var _findExports = require('./findExports');

var _findExports2 = _interopRequireDefault(_findExports);

var _findPackageDependencies = require('./findPackageDependencies');

var _findPackageDependencies2 = _interopRequireDefault(_findPackageDependencies);

var _lastUpdate = require('./lastUpdate');

var _lastUpdate2 = _interopRequireDefault(_lastUpdate);

var _readFile = require('./readFile');

var _readFile2 = _interopRequireDefault(_readFile);

var _forwardSlashes = require('./forwardSlashes');

var _forwardSlashes2 = _interopRequireDefault(_forwardSlashes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/**
 * Checks for package.json or npm-shrinkwrap.json inside a list of files and
 * expands the list of files to include package dependencies if so.
 */
function expandFiles(files, workingDirectory) {
  const promises = [];
  files.forEach(file => {
    if (file.path !== './package.json' && file.path !== './npm-shrinkwrap.json') {
      promises.push(Promise.resolve(file));
      return;
    }
    (0, _findPackageDependencies2['default'])(workingDirectory, true).forEach(dep => {
      let resolvedPath;
      try {
        resolvedPath = (0, _forwardSlashes2['default'])(_path2['default'].relative(workingDirectory, _requireRelative2['default'].resolve(dep, workingDirectory)));
        if (!resolvedPath.startsWith('.')) {
          // path.relative won't add "./", but we need it further down the line
          resolvedPath = './' + String(resolvedPath);
        }
      } catch (e) {
        _winston2['default'].error('Failed to resolve "' + String(dep) + '" relative to ' + String(workingDirectory));
        return;
      }

      promises.push(_lastUpdate2['default'].failSafe(resolvedPath, workingDirectory).then(({ mtime }) => Promise.resolve({
        path: resolvedPath,
        mtime,
        packageName: dep
      })));
    });
  });
  return Promise.all(promises);
}

function aliasedExportNames(alias, ignorePackagePrefixes) {
  const result = [{ name: alias }];
  ignorePackagePrefixes.forEach(prefix => {
    if (alias.startsWith(prefix)) {
      result.push({ name: alias.slice(prefix.length) });
    }
  });
  return result;
}

function defaultExportNames(pathToFile) {
  const parsed = _path2['default'].parse(pathToFile);
  let fileName = parsed.name;
  let dirName = _path2['default'].basename(parsed.dir);

  if (/package\.json|index\.jsx?/.test(parsed.base)) {
    fileName = dirName;
    dirName = _path2['default'].basename(_path2['default'].dirname(parsed.dir));
  }
  if (dirName === '.') {
    return [{
      name: fileName
    }];
  }
  const result = [{
    name: String(dirName) + '-' + String(fileName),
    additional: true
  }, {
    name: fileName
  }];

  if (/e?s$/.test(dirName)) {
    // When the directory has an "s" (or "es") at the end, we assume it's a
    // plural form of something. We then add a third name to the list. As an
    // example, if we have './mocks/ModuleFinder.js' as the pathToFile, we add
    // 'mock-ModuleFinder' here, which will allow the user to find the module
    // with `MockModuleFinder` as the variable name.
    result.push({
      name: String(dirName.replace(/e?s$/, '')) + '-' + String(fileName),
      additional: true
    });
  }
  return result;
}

const instances = {};

class ModuleFinder {
  /**
   * Factory method to get an instance for a specific working directory.
   */
  static getForWorkingDirectory(workingDirectory, { excludes, ignorePackagePrefixes }) {
    let instance = instances[workingDirectory];
    if (!instance) {
      instance = new ModuleFinder(workingDirectory, {
        excludes,
        ignorePackagePrefixes
      });
      instances[workingDirectory] = instance;
    }
    return instance;
  }

  constructor(workingDirectory, { excludes, ignorePackagePrefixes }) {
    this.excludes = excludes;
    this.ignorePackagePrefixes = ignorePackagePrefixes;
    this.workingDirectory = workingDirectory;
    this.storage = new _ExportsStorage2['default']();
    this.watcher = new _Watcher2['default']({
      workingDirectory,
      excludes,
      onFilesAdded: this.handleFilesAdded.bind(this),
      onFilesRemoved: this.handleFilesRemoved.bind(this),
      storage: this.storage
    });
    this.queue = [];
    this.processingQueue = false;
  }

  initializeStorage(dbFilename) {
    return this.storage.init(dbFilename).then(({ isFreshInstall }) => Promise.all(this.excludes.map(glob => this.storage.removeAll(glob))).then(() => this.storage.purgeDeadNodeModules(this.workingDirectory)).then(() => Promise.resolve({ isFreshInstall })));
  }

  startWatcher() {
    return this.watcher.initialize();
  }

  processQueue(done) {
    const file = this.queue.pop();
    if (!file) {
      this.processingQueue = false;
      _winston2['default'].debug('Queue empty');
      done();
      return;
    }
    const pathToFile = file.path,
          mtime = file.mtime,
          packageName = file.packageName;

    this.processingQueue = true;
    _winston2['default'].debug('Processing ' + String(pathToFile));
    const fullPath = _path2['default'].join(this.workingDirectory, pathToFile);
    (0, _readFile2['default'])(fullPath).then(data => {
      let exports = { named: [], typed: [], hasDefault: true };
      try {
        exports = (0, _findExports2['default'])(data, fullPath);
      } catch (e) {
        _winston2['default'].error('Failed to parse ' + String(pathToFile) + ': ' + String(e.message) + '\n' + String(e.stack));
      }
      if (exports.named.length || exports.typed.length || exports.hasDefault) {
        const all = [...exports.named, ...exports.typed.map(t => 'type ' + String(t))];
        if (exports.hasDefault) {
          all.push('default');
        }
        _winston2['default'].debug('Found exports for ' + String(pathToFile) + ':\n' + String(all.join(', ')));
      } else {
        _winston2['default'].debug('No exports found for ' + String(pathToFile));
      }
      const defaultNames = [];
      if (exports.hasDefault) {
        if (packageName) {
          defaultNames.push(...aliasedExportNames(packageName, this.ignorePackagePrefixes));
        } else {
          defaultNames.push(...defaultExportNames(pathToFile));
        }
      }
      this.storage.update({
        names: exports.named,
        types: exports.typed,
        defaultNames,
        pathToFile,
        mtime,
        packageName
      }).then(() => {
        this.processQueue(done);
      })['catch'](error => {
        _winston2['default'].error('Failed to update ' + String(pathToFile) + ' in storage. Reason: ' + String(error.message));
        this.processQueue(done);
      });
    })['catch'](err => {
      _winston2['default'].error(err.message);
      this.processQueue(done);
    });
  }

  handleFilesAdded(unexpandedFiles) {
    return new Promise(resolve => {
      expandFiles(unexpandedFiles, this.workingDirectory).then(files => {
        _winston2['default'].debug('Checking ' + String(files.length) + ' files for potential updates');
        this.storage.needsUpdate(files).then(filesToUpdate => {
          _winston2['default'].debug('Got ' + String(filesToUpdate.length) + ' files to update');
          if (!filesToUpdate.length) {
            resolve();
            return;
          }
          filesToUpdate.forEach(file => {
            this.queue.unshift(file);
            if (!this.processingQueue) {
              _winston2['default'].debug('Kicking off queue');
              this.processQueue(resolve);
            }
          });
        });
      });
    });
  }

  handleFilesRemoved(files) {
    if (!files.length) {
      return Promise.resolve();
    }
    _winston2['default'].debug('Removing ' + String(files.length) + ' files');
    const promises = files.map(({ path: pathToFile }) => {
      _winston2['default'].debug('Removing ' + String(pathToFile));
      return this.storage.remove(pathToFile);
    });
    return Promise.all(promises);
  }

  find(variableName) {
    return this.storage.get(variableName);
  }

  search(variableName) {
    return this.storage.search(variableName);
  }
}
exports['default'] = ModuleFinder;
module.exports = exports['default'];