Object.defineProperty(exports, "__esModule", {
  value: true
});

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _Configuration = require('./Configuration');

var _Configuration2 = _interopRequireDefault(_Configuration);

var _ImportStatement = require('./ImportStatement');

var _ImportStatement2 = _interopRequireDefault(_ImportStatement);

var _forwardSlashes = require('./forwardSlashes');

var _forwardSlashes2 = _interopRequireDefault(_forwardSlashes);

var _requireResolve = require('./requireResolve');

var _requireResolve2 = _interopRequireDefault(_requireResolve);

var _resolveImportPathAndMain = require('./resolveImportPathAndMain');

var _resolveImportPathAndMain2 = _interopRequireDefault(_resolveImportPathAndMain);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

// TODO figure out a more holistic solution than stripping node_modules
function stripNodeModules(path) {
  if (path.startsWith('node_modules/')) {
    return path.slice(13);
  }

  return path;
}

// Class that represents a js module found in the file system
class JsModule {

  /**
   * @param {Boolean} hasNamedExports
   * @param {Boolean} isType
   * @param {String|null} opts.makeRelativeTo a path to a different file which
   *   the resulting import path should be relative to.
   * @param {String} opts.relativeFilePath a full path to the file, relative to
   *   the project root.
   * @param {Array} opts.stripFileExtensions a list of file extensions to strip,
   *   e.g. ['.js', '.jsx']
   * @param {String} opts.variableName
   * @param {String} opts.workingDirectory
   * @return {JsModule}
   */
  static construct({
    hasNamedExports,
    isType = false,
    makeRelativeTo,
    relativeFilePath,
    stripFileExtensions,
    variableName,
    workingDirectory = process.cwd()
  } = {}) {
    const jsModule = new JsModule();
    jsModule.filePath = relativeFilePath;

    const importPathAndMainFile = (0, _resolveImportPathAndMain2['default'])(jsModule.filePath, stripFileExtensions, workingDirectory);
    const importPath = importPathAndMainFile[0];
    const mainFile = importPathAndMainFile[1];

    if (!importPath) {
      return null;
    }

    if (mainFile) {
      jsModule.filePath = (0, _forwardSlashes2['default'])(_path2['default'].normalize(_path2['default'].join(importPath, mainFile)));
    }

    jsModule.importPath = importPath;
    jsModule.hasNamedExports = hasNamedExports;
    jsModule.isType = isType;
    jsModule.variableName = variableName;
    if (makeRelativeTo) {
      jsModule.makeRelativeTo(makeRelativeTo);
    } else {
      jsModule.importPath = jsModule.importPath.replace(/^\.\//, '');
    }
    return jsModule;
  }

  constructor({
    hasNamedExports,
    isType = false,
    importPath,
    variableName
  } = {}) {
    this.hasNamedExports = hasNamedExports;
    this.isType = isType;
    this.importPath = importPath;
    this.variableName = variableName;
  }

  makeRelativeTo(makeRelativeToPath) {
    let importPath = _path2['default'].relative(_path2['default'].dirname(makeRelativeToPath), this.importPath);

    importPath = (0, _forwardSlashes2['default'])(importPath);

    // `path.relative` will not add "./" automatically
    if (!importPath.startsWith('.')) {
      importPath = './' + String(importPath);
    }

    this.importPath = importPath;
  }

  resolvedFilePath(pathToCurrentFile, workingDirectory = process.cwd()) {
    if (this.filePath) {
      return this.filePath;
    }

    // There is no filePath. This likely means that we are working with an
    // alias, so we want to expand it to a full path if we can.
    if (this.importPath.startsWith('.')) {
      // The import path in the alias starts with a ".", which means that it is
      // relative to the current file. In order to open this file, we need to
      // expand it to a full path.
      return (0, _forwardSlashes2['default'])(_path2['default'].resolve(_path2['default'].dirname(pathToCurrentFile), this.importPath));
    }

    // If all of the above fails to find a path, we fall back to using
    // require.resolve() to find the file path.
    const unresolved = _path2['default'].join(workingDirectory, this.importPath);
    const resolved = (0, _requireResolve2['default'])(unresolved);
    if (unresolved !== resolved) {
      // We found a location for the import
      return resolved;
    }
    // as a last resort, assume it's a package dependency
    return (0, _requireResolve2['default'])(_path2['default'].join(workingDirectory, 'node_modules', this.importPath));
  }

  _getNamedImports() {
    if (!this.hasNamedExports) {
      return [];
    }
    return [{ localName: this.variableName, isType: this.isType }];
  }

  _getDefaultImport() {
    if (this.hasNamedExports) {
      return '';
    }
    return this.variableName;
  }

  toImportStatement(config) {
    const namedImports = this._getNamedImports();
    const defaultImport = this._getDefaultImport();
    // TODO figure out a more holistic solution than stripping node_modules
    const pathToImportedModule = stripNodeModules(this.resolvedFilePath(config.pathToCurrentFile, config.workingDirectory));

    return new _ImportStatement2['default']({
      declarationKeyword: config.get('declarationKeyword', {
        pathToImportedModule
      }),
      defaultImport,
      hasSideEffects: false,
      importFunction: config.get('importFunction', { pathToImportedModule }),
      namedImports,
      areOnlyTypes: this.isType,
      danglingCommas: config.get('danglingCommas'),
      path: config.get('moduleNameFormatter', {
        pathToImportedModule,
        // TODO figure out a more holistic solution than stripping node_modules
        moduleName: stripNodeModules(this.importPath)
      })
    });
  }
}
exports['default'] = JsModule;
module.exports = exports['default'];