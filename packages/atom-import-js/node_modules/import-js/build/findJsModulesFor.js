Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.dedupeAndSort = dedupeAndSort;
exports['default'] = findJsModulesFor;

var _minimatch = require('minimatch');

var _minimatch2 = _interopRequireDefault(_minimatch);

var _sortBy = require('lodash/sortBy');

var _sortBy2 = _interopRequireDefault(_sortBy);

var _uniqBy = require('lodash/uniqBy');

var _uniqBy2 = _interopRequireDefault(_uniqBy);

var _Configuration = require('./Configuration');

var _Configuration2 = _interopRequireDefault(_Configuration);

var _JsModule = require('./JsModule');

var _JsModule2 = _interopRequireDefault(_JsModule);

var _ModuleFinder = require('./ModuleFinder');

var _ModuleFinder2 = _interopRequireDefault(_ModuleFinder);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function findImportsFromEnvironment(config, variableName) {
  return config.get('coreModules').filter(dep => dep.toLowerCase() === variableName.toLowerCase()).map(dep => new _JsModule2['default']({
    importPath: dep,
    variableName
  }));
}

function findJsModulesFromModuleFinder(config, normalizedName, variableName, finder, pathToCurrentFile, options = {}) {
  return new Promise((resolve, reject) => {
    let isWantedPackageDependency = Boolean;
    if (!config.get('importDevDependencies')) {
      const packageDependencies = config.get('packageDependencies');
      isWantedPackageDependency = packageName => packageDependencies.has(packageName);
    }

    const isSearch = !!options.search;
    const method = isSearch ? 'search' : 'find';

    finder[method](normalizedName).then(exports => {
      const modules = exports.map(({
        name,
        path,
        isDefault,
        isType,
        packageName
      }) => {
        // eslint-disable-line object-curly-newline
        // Filter out modules that are in the `excludes` config.
        const isExcluded = config.get('excludes').some(glob => (0, _minimatch2['default'])(path, glob));
        if (isExcluded) {
          return undefined;
        }

        if (packageName) {
          if (!isWantedPackageDependency(packageName)) {
            return undefined;
          }
          return new _JsModule2['default']({
            importPath: packageName,
            variableName: isSearch ? name : variableName,
            hasNamedExports: !isDefault,
            isType
          });
        }

        return _JsModule2['default'].construct({
          hasNamedExports: !isDefault,
          isType,
          relativeFilePath: path,
          stripFileExtensions: config.get('stripFileExtensions', {
            pathToImportedModule: path
          }),
          makeRelativeTo: config.get('useRelativePaths', {
            pathToImportedModule: path
          }) && config.pathToCurrentFile,
          variableName: isSearch ? name : variableName,
          workingDirectory: config.workingDirectory
        });
      });
      resolve(modules.filter(Boolean));
    })['catch'](reject);
  });
}

function dedupeAndSort(modules) {
  // We might end up having duplicate modules here.  In order to dedupe
  // these, we remove the module with the longest path
  const sorted = (0, _sortBy2['default'])(modules, module => module.importPath.length);
  const uniques = (0, _uniqBy2['default'])(sorted,
  // Default export and named export with same name from the same module are not considered dupes
  module => [module.importPath, module.hasNamedExports].join());
  // Sorting by path, but with default exports before named exports
  return (0, _sortBy2['default'])(uniques, module => [module.importPath, module.hasNamedExports ? 1 : 0].join());
}

const NON_PATH_ALIAS_PATTERN = /^[a-zA-Z0-9-_]+$/;

function findJsModulesFor(config, variableName, options) {
  return new Promise((resolve, reject) => {
    let normalizedName = variableName;
    const alias = config.resolveAlias(variableName);
    if (alias) {
      if (NON_PATH_ALIAS_PATTERN.test(alias)) {
        // The alias is likely a package dependency. We can use it in the
        // ModuleFinder lookup.
        normalizedName = alias;
      } else {
        // The alias is a path of some sort. Use it directly as the moduleName
        // in the import.
        resolve([new _JsModule2['default']({ importPath: alias, variableName })]);
        return;
      }
    }

    const namedImportsModule = config.resolveNamedExports(variableName);
    if (namedImportsModule) {
      resolve([namedImportsModule]);
      return;
    }

    const matchedModules = [];

    matchedModules.push(...findImportsFromEnvironment(config, variableName));

    const finder = _ModuleFinder2['default'].getForWorkingDirectory(config.workingDirectory, {
      excludes: config.get('excludes'),
      ignorePackagePrefixes: config.get('ignorePackagePrefixes')
    });
    findJsModulesFromModuleFinder(config, normalizedName, variableName, finder, config.pathToCurrentFile, options).then(modules => {
      matchedModules.push(...modules);
      resolve(dedupeAndSort(matchedModules));
    })['catch'](error => {
      reject(error);
    });
  });
}