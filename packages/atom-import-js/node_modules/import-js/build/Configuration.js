Object.defineProperty(exports, "__esModule", {
  value: true
});

var _crypto = require('crypto');

var _crypto2 = _interopRequireDefault(_crypto);

var _os = require('os');

var _os2 = _interopRequireDefault(_os);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _has = require('lodash/has');

var _has2 = _interopRequireDefault(_has);

var _globals = require('globals');

var _globals2 = _interopRequireDefault(_globals);

var _semver = require('semver');

var _semver2 = _interopRequireDefault(_semver);

var _FileUtils = require('./FileUtils');

var _FileUtils2 = _interopRequireDefault(_FileUtils);

var _JsModule = require('./JsModule');

var _JsModule2 = _interopRequireDefault(_JsModule);

var _findPackageDependencies = require('./findPackageDependencies');

var _findPackageDependencies2 = _interopRequireDefault(_findPackageDependencies);

var _meteorEnvironment = require('./environments/meteorEnvironment');

var _meteorEnvironment2 = _interopRequireDefault(_meteorEnvironment);

var _nodeEnvironment = require('./environments/nodeEnvironment');

var _nodeEnvironment2 = _interopRequireDefault(_nodeEnvironment);

var _normalizePath = require('./normalizePath');

var _normalizePath2 = _interopRequireDefault(_normalizePath);

var _version = require('./version');

var _version2 = _interopRequireDefault(_version);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

const JSON_CONFIG_FILE = '.importjs.json';

const JS_CONFIG_FILE = '.importjs.js';

function findGlobalsFromEnvironments(environments) {
  const result = Object.keys(_globals2['default'].builtin);

  environments.forEach(environment => {
    const envGlobals = _globals2['default'][environment];
    if (!envGlobals) {
      return;
    }
    result.push(...Object.keys(envGlobals));
  });
  return result;
}

const DEFAULT_CONFIG = {
  aliases: {},
  declarationKeyword: 'import',
  cacheLocation: ({ config }) => {
    const hash = _crypto2['default'].createHash('md5').update(String(config.workingDirectory) + '-v4').digest('hex');
    return _path2['default'].join(_os2['default'].tmpdir(), 'import-js-' + String(hash) + '.db');
  },
  coreModules: [],
  namedExports: {},
  environments: [],
  excludes: [],
  globals: ({ config }) => findGlobalsFromEnvironments(config.get('environments')),
  groupImports: true,
  ignorePackagePrefixes: [],
  importDevDependencies: false,
  importFunction: 'require',
  importStatementFormatter: ({ importStatement }) => importStatement,
  logLevel: 'info',
  maxLineLength: 80,
  minimumVersion: '0.0.0',
  moduleNameFormatter: ({ moduleName }) => moduleName,
  moduleSideEffectImports: () => [],
  sortImports: true,
  emptyLineBetweenGroups: true,
  stripFileExtensions: ['.js', '.jsx'],
  danglingCommas: true,
  tab: '  ',
  useRelativePaths: true,
  packageDependencies: ({ config }) => (0, _findPackageDependencies2['default'])(config.workingDirectory, config.get('importDevDependencies')),
  // Default configuration options, and options inherited from environment
  // configuration are overridden if they appear in user config. Some options,
  // however, get merged with the parent configuration. This list specifies which
  // ones are merged.
  mergableOptions: {
    aliases: true,
    coreModules: true,
    namedExports: true,
    globals: true
  }
};

const KNOWN_CONFIGURATION_OPTIONS = ['aliases', 'cacheLocation', 'coreModules', 'declarationKeyword', 'environments', 'excludes', 'globals', 'groupImports', 'ignorePackagePrefixes', 'importDevDependencies', 'importFunction', 'importStatementFormatter', 'logLevel', 'maxLineLength', 'minimumVersion', 'moduleNameFormatter', 'moduleSideEffectImports', 'namedExports', 'sortImports', 'stripFileExtensions', 'tab', 'useRelativePaths', 'mergableOptions', 'danglingCommas', 'emptyLineBetweenGroups'];

const DEPRECATED_CONFIGURATION_OPTIONS = [];

const ENVIRONMENTS = {
  node: _nodeEnvironment2['default'],
  meteor: _meteorEnvironment2['default']
};

function checkForUnknownConfiguration(config) {
  const messages = [];

  Object.keys(config).forEach(option => {
    if (KNOWN_CONFIGURATION_OPTIONS.indexOf(option) === -1) {
      messages.push('Unknown configuration: `' + String(option) + '`');
    }
  });

  return messages;
}

function checkForDeprecatedConfiguration(config) {
  const messages = [];

  Object.keys(config).forEach(option => {
    if (DEPRECATED_CONFIGURATION_OPTIONS.indexOf(option) !== -1) {
      messages.push('Using ' + String(option) + ' to configure ImportJS is deprecated and ' + 'will go away in a future version.');
    }
  });

  return messages;
}

/**
  * Checks that the current version is bigger than the `minimumVersion`
  * defined in config.
  * @throws Error if current version is less than the `minimumVersion` defined
  * in config.
  */
function checkCurrentVersion(minimumVersion) {
  if (_semver2['default'].gte((0, _version2['default'])(), minimumVersion)) {
    return;
  }

  throw Error('The configuration file for this project requires version ' + String(minimumVersion) + ' or newer. You are using ' + String((0, _version2['default'])()) + '.');
}

function mergedValue(values, key, options) {
  let mergedResult;
  for (let i = 0; i < values.length; i += 1) {
    let value = values[i];
    if (typeof value === 'function') {
      value = value(options);
    }
    // Prevent an endless loop of mergedValue calls
    // The mergableOptions key will get merged by skipping this check
    if (key !== 'mergableOptions') {
      const mergableOptions = options.config.get('mergableOptions');
      if (mergableOptions[key] !== true) {
        // This key shouldn't be merged
        return value;
      }
    }
    if (Array.isArray(value)) {
      mergedResult = (mergedResult || []).concat(value);
    } else if (typeof value === 'object') {
      mergedResult = Object.assign({}, value, mergedResult || {});
    } else {
      // Neither an object nor an array, so we just return the first value we
      // have.
      return value;
    }
  }
  return mergedResult;
}

// Class that initializes configuration from a .importjs.js file
class Configuration {

  constructor(pathToCurrentFile, workingDirectory = process.cwd()) {
    this.workingDirectory = workingDirectory;
    this.pathToCurrentFile = (0, _normalizePath2['default'])(pathToCurrentFile, workingDirectory);

    this.messages = [];
    this.configs = [];

    let userConfig;
    try {
      userConfig = this.loadUserConfig();
    } catch (error) {
      this.messages.push('Unable to parse configuration file. Reason:\n' + String(error.stack));
    }

    if (userConfig) {
      this.configs.push(userConfig);
      this.messages.push(...checkForUnknownConfiguration(userConfig));
      this.messages.push(...checkForDeprecatedConfiguration(userConfig));

      // Add configurations for the environments specified in the user config
      // file.
      // Don't use `this.get` because the config hasn't finished initalizing.
      // Use userConfig instead since it's the only one declared
      if (typeof userConfig.environments === 'function') {
        userConfig.environments = userConfig.environments({
          config: this,
          pathToCurrentFile: this.pathToCurrentFile
        });
      }
      (userConfig.environments || []).forEach(environment => {
        const envConfig = ENVIRONMENTS[environment];
        if (envConfig) {
          this.configs.push(envConfig);
        }
      });
    }

    this.configs.push(DEFAULT_CONFIG);

    checkCurrentVersion(this.get('minimumVersion'));
  }

  get(key, {
    pathToImportedModule,
    moduleName,
    importStatement
  } = {}) {
    const applyingConfigs = this.configs.filter(config => Object.prototype.hasOwnProperty.call(config, key));

    return mergedValue(applyingConfigs.map(config => config[key]), key, {
      pathToImportedModule,
      moduleName,
      config: this,
      pathToCurrentFile: this.pathToCurrentFile,
      importStatement
    });
  }

  loadUserConfig() {
    const jsConfig = _FileUtils2['default'].readJsFile(_path2['default'].join(this.workingDirectory, JS_CONFIG_FILE));

    if (jsConfig && Object.keys(jsConfig).length === 0) {
      // If you forget to use `module.exports`, the config object will be `{}`.
      // To prevent subtle errors from happening, we surface an error message to
      // the user.
      throw new Error('Nothing exported from ' + JS_CONFIG_FILE + '. You need to use `module.exports` to specify what gets exported from the file.');
    }

    if (jsConfig) {
      return jsConfig;
    }

    const jsonConfig = _FileUtils2['default'].readJsonFile(_path2['default'].join(this.workingDirectory, JSON_CONFIG_FILE));

    if (jsonConfig) {
      this.messages.push('Using JSON to configure ImportJS is deprecated and will go away in a future version. Use an `.importjs.js` file instead.');
      return jsonConfig;
    }

    const globalConfig = _FileUtils2['default'].readJsFile(_path2['default'].join(_os2['default'].homedir(), JS_CONFIG_FILE));

    return globalConfig;
  }

  resolveAlias(variableName) {
    if (!(0, _has2['default'])(this.get('aliases'), variableName)) {
      return null;
    }

    let importPath = this.get('aliases')[variableName];

    importPath = importPath.path || importPath; // path may be an object

    if (this.pathToCurrentFile !== './') {
      // aliases can have dynamic `{filename}` parts
      importPath = importPath.replace(/\{filename\}/, _path2['default'].basename(this.pathToCurrentFile, _path2['default'].extname(this.pathToCurrentFile)));
    }
    return importPath;
  }

  resolveNamedExports(variableName) {
    const allNamedExports = this.get('namedExports');
    const importPath = Object.keys(allNamedExports).find(key => allNamedExports[key].indexOf(variableName) !== -1);

    if (!importPath) {
      return undefined;
    }

    const jsModule = new _JsModule2['default']({
      importPath,
      hasNamedExports: true,
      variableName
    });
    return jsModule;
  }
}
exports['default'] = Configuration;
module.exports = exports['default'];